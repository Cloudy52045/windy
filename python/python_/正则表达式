—————— 正则表达式
listeral  匹配文本字符串的字面值---foo
re1|re2   匹配正则表达式re1或re2---foo|bar
.         匹配任何字符（除\n之外）---b.b
^         匹配字符串起始部分---^Dear
$         匹配字符串终止部分---/bin/*sh$
*         匹配0次或多次前面出现的正则表达式---[A-Za-z0-9]*
+         匹配1次或多次前面出现的正则表达式---[a-z]+\.com
？        匹配0次或1次前面出现的正则表达式---goo?
{N}       匹配N次前面出现的正则表达式---[0-9]{3}
{M,N}     匹配M~N前面出现的正则表达式---[0-9]{5,9}
[...]     匹配来自字符集的任意单一字符---[aeiou]
[..x-y..] 匹配x-y范围中的任意单一字符---[0-9],[A-Za-z0-9]
[^...]    不匹配字符集中出现的任何一个字符，包括某一范围的字符（如果在此字符中出现）---[^aeiou],[^A-Za-z0-9]
(*|+|?|{})? 用于匹配上面频繁出现/重复出现符号的非贪婪版本（* + ? {}）---.*?[a-z]
(...)     匹配封闭的正则表达式，然后另存为子组---([0-9]{3})?,f(oo|u)bar
\d        匹配任何十进制的数字，与[0-9]一致，（\D与\d相反，不匹配任何非数值型的数字）
\w        匹配任何数字字母字符，与[A-Za-z0-9]相同（\W与之相反）
\s        匹配任何空格字符，与[\n\t\r\v\f]相同，（\s与之相反）
\b        匹配任何单词边界，（\B与之相反）
\N        匹配已保存的子组N
\A(\Z)    匹配字符串的起始

————   扩展表示法
(?iLmsux)       在正则表达式中嵌入一个或者多个特殊“标记”的参数（或者通过函数/方法）
(?:...)         表示一个匹配不用保存的分组
(?P<name>...)   像一个仅由name标识的而不是数字的ID标识的正则分组匹配
(?P<name>)      在同一个字符串中匹配由(?P<name>)分组的之前文本
(?#...)         表示注释,所有内容都被忽略
(?=...)         匹配条件是如果...出现在之后的位置,而不使用输入字符串;称作正向前视断言
(?!...)         匹配条件是如果...不出现在之后的位置,而不使用输入字符串;称作负向前视断言
(?<=...)        匹配条件是如果...出现在之后的位置,而不使用输入字符串;称作正向后视断言
(?<!...)        匹配条件是如果...不出现在之前的位置,而不使用输入字符串;称作负向后视断言
(?(id/name)Y/N) 如果分组提供的id或者name(名称)存在,就返回正则表达式的条件匹配Y,如果不存在,就返回N;/N是可选项

———— 使用择一匹配符
——    表示一个“从多个模式中选择其中一”的模式，它用于分割不同的正则表达式
  
———— 匹配任意单个字符
——    点号或者句号（.）符号匹配除了换行符\n以外的任何字符，（python正则表达式有一个编译标记[s或者DOTALL]，该标记能够推翻这个限制，是点号能够匹配换行符）。
——    无论字母、数字、空格（不包括“\n”换行符）、可打印字符、不可打印字符，还是一个符号，使用点号都可以匹配它们。
 f.o   匹配在字母“f”和“o”之间的任意一个字符，例如：fao、f9o、f#o等
 ..    任意两字符
 .end  匹配在字符串end之前的任意一个字符
 
————   从字符串起始或者结尾或者单词边界匹配
 ^from  任何以from作为起始的字符串
 /bin/tcsh$   任何以/bin/tcsh作为结尾的字符串
 ^Subject:hi$   任何由单独的字符串Subject:hi构成的字符串
 
注：如果想要逐字匹配这些字符串中的任意一个（或者全部），就必须使用反斜线进行转译
the   任何包含the的字符串
\bthe   任何以the开头的字符串
\bthe\b   仅仅匹配单词the
\Bthe   任何包含但并不以the作为起始的字符串

————    创建字符集
——    匹配一对方括号中包含的的任何字符
b[aeiu]t    bat、bet、bit、but
[cr][23][dp][o2]    c2do、r3p2、r2d2、c3po

————    限定范围和否定
——    如果脱字符（^）在字符集左方括号的后面，这个符号就表示不匹配该字符集里面的字符
z.[0-9]   字母“z”后面跟着任何一个字符，然后跟着一个数字
[r-u][env-y][us]    r|s|t|u.e|n|v|w|x|y.u|s
[^aeiou]    一个非元音字符
[^\t\n]   不匹配制表符或者\n
["-a]   在一个ASCII系统中，所有字符都位于“”和“a“之间，及34~97之间

————    使用闭包操作符实现存在性和频数匹配
——    主要的符号为 *、+、?
*         匹配0次或多次前面出现的正则表达式---[A-Za-z0-9]*
+         匹配1次或多次前面出现的正则表达式---[a-z]+\.com
?         匹配0次或1次前面出现的正则表达式---goo?

[dn]ot?   字母“d”or“n”，后面跟着一个“o”，然后最多一个“t”，例如：do、no、dot、not
0?[1-9]   任何数值数字，它可能前置一个“0”
[0-9]{15,16}      匹配15或者16个数字（例如信用卡号码）
</?[^>]+>   匹配全部有效的（和无效的）HTML标签
[KQRBNP][a-h][1-8]-[a-h][1-8]   在“长数法”标记法中，表示象棋合法的的期盼移动

————    表示字符集的特殊字符
——  d   表示匹配任何十进制的数字 0-9
——  \w  能够用于表示全部的字母数字的字符集
——  \s  表示空格符

\w+-\d+             一个由字母数字组成的字符串和一串由一个连分隔的数字
[A-Za-z]\w*          第一个字符的字母；其余字符（如果存在）可以是字母或者数字（几乎等价于python中的有效标识符）
\d{3}-\d{3}-\d{4}   美国手机号码格式，前面是区号前缀
\w+@\w+\.com        以xxx@yyy.com格式表示的简单电子邮箱地址

————    使用原括号指定分组
\d+(\.\d*)?   表示简单浮点数的字符串；也就是说，任何的十进制数字，后面可以接一个小数点和零个或者多个十进制数字，例如“0.004”，“2”
(Mr?s?\.)?[A-Z][a-z]*[A-Za-z]+    名字和姓氏，以及对名字的限制（如果有，首字母必须大写，后续字母小写），全名前可以有可选的

————    扩展表示法
——    (?p<name>)    表述一个分组匹配
(?:\w+\.)*    以句号结尾的字符串，例如："google."、"twitter.",但是这些匹配不会保存下来
(?#comment)   此处并不做匹配，只是作为注释
(?=.com)      如果一个字符串后面跟着".com"才做匹配操作，并不使用任何目标字符串
(?!.net)      如果字符串之前为".net"才做匹配操作
(?<=800-)     如果字符串之前为"800-"才做匹配，假定为电话号码，并不使用任何输入字符串
(?<!192\.168\.) 如果字符串之前不是"192.168"才做匹配操作，假定用于过滤掉一组C类IP地址
(?(1)y|x)     如果一个匹配组1(\1)存在，就与y匹配，否则，就与x匹配


